---
title: "Introduction to Fluidigr"
author: "Otho Mantegazza"
date: "`r Sys.Date()`"
output:
  knitr:::html_vignette:
    toc: yes
    number_sections: true
    highlight: default
vignette: >
  %\VignetteIndexEntry{Introduction to Fluidigr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Setup

```{r setup, message = FALSE}
library(fluidigr)
library(magrittr)
library(dplyr)
library(stringr)
library(ggplot2)
library(forcats)
library(scales)
```

# Simple Workflow

Record the path to your fluidigm CSV data and the name of your reference normalizers.

```{r}
path_to_data <- system.file("extdata", "sample-fluidigm-run.csv",
                            package = "fluidigr",
                            mustWork = TRUE)

normalizers <- c("normalizer1",
                 "normalizer2",
                 "normalizer3")
```


Parse them, normalize them and scale them in a [magrittr](https://magrittr.tidyverse.org/index.html) pipe.

```{r, eval=FALSE}
fluidigm_data <- 
  path_to_data %>%
  read_fluidigm() %>%
  normalize() %>%
  scale_fluidigm()
```

And your data are ready to be plotted in ggplot2.

In the next paragraphs you'll find this same workflow explained in details

# Load your data into R

```{r}
dat <- read_fluidigm(path = path_to_data)
```

## Make your data tidy

After you have parsed the data, you can modify them using [dplyr](https://dplyr.tidyverse.org/articles/dplyr.html) as you wish.


Example, remove samples:

Our example dataset contains samples that are dilution used for calibration curves.

```{r}
dat$sample_name %>% unique()
```

Those samples, all have the word "Mix" in their name, and can be removed with:

```{r}
dat <- 
  dat %>%
  filter(!sample_name %>% str_detect("Mix"))
```

One sample "H2O" is a negative control, it also can be removed:

```{r}
dat <- 
  dat %>%
  filter(sample_name != "H20")
```

You can check that each sample has been measured the same number of times:

```{r}
dat$sample_name %>% table()
dat$sample_name %>% table() %>% unique()
```

Also, one of the target is a duplicated normalizer. We can remove it with:

```{r}
dat$target_name %>% unique()

dat <- 
  dat %>%
  filter(target_name != "normalizer1bis")
```


# Normalize

You must provided the names of the normalizers exactly as they are stored in the `target_name` column. In this case the name of the normalizers is: `normalizer1`, `normalizer2` and `normalizer3`.

```{r}
normalizers <- c("normalizer1",
                 "normalizer2",
                 "normalizer3")

norm_dat <- 
  dat %>% 
  normalize(normalizers = normalizers) 
```

The `normalize()` function takes the data parsed by `read_fluidigm()` as object and returns the same data with two additional columns:

- `norm_geom_mean` stores the geometric mean of normalizers for each sample.
- `expression` stores the normalized expression values.

Expression values are normalized with the formula: 

$$expression = 2^{-(C_T - C_Tnorm)}$$

Where, for each well, $C_T$ is the recorded threshold cycle (`ct_value`) and $C_Tnorm$ is the geometric mean of the normalizers C~T~ values.

# Scale

Scaling is not necessary, but, together with exploratory plots, it can help you detect patterns in your data. Indeed, the outcome of scaling will be discussed in the next section "Visualize".

Fluidgr provides the `scale_fluidigm()` function, that scales expression values with z-score scaling according to the groups provided in the argument `.group`.

This function takes the dataset output of `normalize()` and returns the same dataset with the extra column `scaled_expression`.

```{r}
scaled_dat <- 
  norm_dat %>% 
  scale_fluidigm(.group = target_name)
```

The `scale_fluidigm()` function is a soft wrapper around dplyr's `group_by()` and `mutate()`. If you want to try different scaling methods, you can repliate it's output with:

```{r, eval = FALSE}
norm_dat %>%
  group_by(target_name) %>%
  mutate(scaled_expression = scale(expression))
```

This should provide a good basis and enough freedom to explore and visualize your data as you prefer.

# Visualize

Fluidigmr does not provide plotting function, because all the functions that you need to plot this kind of data are already available in [ggplot2](https://ggplot2.tidyverse.org/). Indeed the dataset output of is already in a [tidy/gathered format](http://r4ds.had.co.nz/tidy-data.html).

Here we provide some ideas of how you can explore, plot and visualize your Fluidigm data.

## What variables are in your data?

Make the variables in your data explicit.

Effective visualization depends from the variable that determine the effect in your dataset and eventually by the question that you are trying to anwser.

For example in the sample dataset we are measuring the expression of four genes in 4 developmental stages in 5 species. 
The column `target_name` records the "gene" variable, while the other two variables, developmental stage and species, are hidden in the `sample_name` variable. We can make them explicit. 

The `sample_name` variable is encoded as "J-N1R1":

- The first letter "J" is the species.
- The letter and the number after the hyphen "N1" encode for the stage.
- The last letter and number "R1" encode for the replicate.

```{r}
norm_dat <- 
  norm_dat %>%
  # make species explicit
  mutate(species = str_split_fixed(string = sample_name,
                                   pattern = "-",
                                   n = 2)[, 1]) %>%
  # make stage explicit
  mutate(stage = str_sub(string = sample_name,
                         start = 3,
                         end = 4)) %>%
  # make replicate explicit
  mutate(replicate = str_sub(string = sample_name,
                         start = 5,
                         end = 6))
```

## Lineplot

A lineplot can be informative directly on normalized data, without scaling.

You can use facets to display multivariate data.

```{r, fig.height=6}
p <- norm_dat %>%
  ggplot(aes(x = stage,
             y = expression)) +
  # plot each expression value into a point
  geom_point(size = 2,
               col = "#DA614D",
               alpha = .8) +
  # it might be complicated to add a line that connect means
  # across stages,
  # because stages are encoded as a categorical variable,
  # we must turn them into numeric
  stat_summary(aes(x = stage %>%
                     as.factor(.) %>%
                     as.numeric(.)),
               fun.y = mean,
               geom="line",
               size = 1.2,
               alpha = .7,
               linejoin = "round") +
  # implement facetting with independent y values
  # for each genes, since expression values are
  # not comparable across genes
  facet_grid(target_name ~ species,
               scales = "free_y") +
  theme_bw() 

p %>% print()
```

Some patterns in your data might be more evident if you plot them in log  scale.

```{r, warning=FALSE, fig.height=6}
p_log <- 
  p + scale_y_log10()

p_log %>% print()
```

Also using heatmap with ggplot2

```{r, fig.height=2}
p_heat <- 
  norm_dat %>%
  ggplot(aes(x = stage,
             y = target_name,
             fill = expression)) +
  geom_tile() +
  facet_grid(. ~ species) +
  scale_fill_viridis_c()

p_heat %>% print()
```

Sometime heatmap don't convey muich invormation if you don't scale your data.

For example we can scale every gene on z-score to make them comparable.

```{r}
scaled_gene <- 
  norm_dat %>% 
  group_by(target_name) %>%
  mutate(scaled_expression = expression %>%
           rescale(from = range(.), to = c(0,1)))
```

Check if the heatmap has improved

**remeber to map the colours to the new `scaled_expression` values**

```{r, fig.height=2}
p_heat <- 
  scaled_gene %>%
  ggplot(aes(x = stage,
             y = species,
             fill = scaled_expression)) +
  geom_tile() +
  facet_grid(. ~ target_name) +
  scale_fill_viridis_c()

p_heat %>% print()
```

We can try to set more groups.

```{r}
scaled_dat <- 
  norm_dat %>%
  group_by(target_name, species) %>%
  mutate(scaled_expression = expression %>%
           rescale(from = range(.), to = c(0,1)))
```

Check if the heatmap has improved

**remeber to map the colours to the new `scaled_expression` values**

```{r,  fig.height=2}
p_heat <- 
  scaled_dat %>%
  ggplot(aes(x = stage,
             y = species,
             fill = scaled_expression)) +
  geom_tile() +
  facet_grid(. ~ target_name) +
  scale_fill_viridis_c()

p_heat %>% print()
```

# Session Info

```{r}
devtools::session_info()
```
